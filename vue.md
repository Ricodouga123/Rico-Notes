## Vue.js 3 Custom Directives

v-if: conditionally render an element

v-on: binding reactive data to a specific attribute

Argument is the part of the after the colon of the directives. e.g. the 'href' in 'v-bind:href'

You can apply modifiers at the end of the argument to perform action on the event received. Such as 'v-on:click.prevent' to prevent the default action of the event.

You can create custom directives in the script section.

```
const vColor = (el, binding) => {
    //how to access the element values
    el.style
    el.color

    //how to access arguments, values and modifiers
    binding.value
    binding.argument
    binding.modifiers.whateverModifiersPassed
}
```
and apply them

```
<div v-color:blue> texts </div>
```

You can create hooks for custom directives so they mimic behaviors that occur at different lifecycle hooks. e.g. mounted and created

```
const myDirective = {
    created(el, binding, vnode, prevVnode){

    },

    mounted(el, binding, vnode, prevVnode){

    }
}
```

you can set values to the element and access it in a different hook. The convention is to have double underscore on the name to prevent collision, and prefix it with the name of your custom directive

```
const myDirective = {
    created(el, binding, vnode, prevVnode){
        el.__myDirectiveString__ = "The value"
    },

    mounted(el, binding, vnode, prevVnode){
        el.__myDirectiveString__ = "The value changed on mounted"
    }
}
```

you can register a directive globally at the app level
```
const app = createApp({})

// make v-focus usable in all components
app.directive('focus', {
  /* ... */
})

```

stuff I didn't understand: document.body. What is this document?

## Functional Components

why functional component? If you need to have a page that display all the blogs in one page, you want to render blogs as user scroll down, instead of rendering all thousands of blogs at once. and if the total number of blogs post change, the page need to rerender all of the blogs again, making it inefficient. Functional component solves this problem.

make a component functional by adding the keyword 'functional' in the template. Note that after this change, the component no longer has access to the Vue instance. But the component will still have access to the context object.

```
<template functional></template>
```

Because the functional component no longer has accesss to the Vue instance and only has access to the context object. emiting custom events is no longer possible, e.g. `this.$emit()`. You will have to do something like

```
<v-btn @click = "listeners.theEventParentListensTo></v-btn>
```

native modifiers won't be available for the functional components.

Using template for functional component can be quite limiting. Functional rendering is very powerful.

```
<script>
render (hyperText, context) {
    return hyperText(context.props.someProp, context.children)
}
</script>
```

This way, the html is generated by this render function.

Render function can be nested.

## Nuxt.js 

Advantage of Nuxt:

* built on top of vue
* Provides server side rendering and universal rendering, while vue only provides client side rendering
* Devloper conveniences like auto imported components, file-based routing, typescript support.

Watched a little bit and I think it's not too applicable to what we do so I skipped after watching a few sections.

# Pinia

Pinia is a state management solution. Props down, events up is a good solution for small scale apps, but gets out of hand when multiple components need to communicate with each other. Pinia provides a global state manager.

Pinia is type safe. So variables won't mutate their data type on transfer.

Pinia can be included on initiating a vue project

After setting up Pinia, to create a store, in a js file

```
import {defineStore} from "pinia"

export const useProductStore = defineStore( id: "ProductStore", options: {
    state: () => {
        return {//Whatever the initial state should be}
    }
})
```

To use this store, in any other file

```
import {useProductStore} from "/fileWhereTheStoreIs"

useProductStore();
```

and the store will be initiated.

The data in the store has a two-way bind. So any change will be reflected.

If you only want part of the data stored in the store, e.g. only the state stored and not any action. you can do

```
import {useProductStore} from "/fileWhereTheStoreIs"
import {storeToRefs} from "Pinia

const {products} = storeToRefs(userProductStore());
```

the storeToRefs is needed to ensure reactivity.

For data that require static import, you can do async/await for a easier time to write the API

```
async fill () {
    this.products = (await import ("@/data/products.json)).default;
}
```

you can directly mutate Pinia data state

```
ProductStore.items.push('someDataHere')
```

you can group multiple mutations together like such:

```
ProductStore.$patch((state) => {
    for (let index = 0; index < count; index++) {
        state.items.push(product)
    }


})
```
Direct mutation is OK but not generally recommended. It is more appropriate to define the mutations as actions. This way it can be reused just like functions.

The getters in store is very similar to computed props, it can return value based on the state of the store. So for a Pinia store, it has state, getters, and actions which similarly corresponds to data, computed, and methods in a typical component script.

## Master Class

### Chapter 1

Vue CLI gives convenient boiler plate to speed up development (Vite is better now)

node_module folder contains all the packages installed by npm

src contains application code

main.js is used to instantiating and connecting plugins

use ESLint for static code review

### Chapter 2

JSON and XML are common file formats for transferring data.

Although you can pass around JSON data, it's better to have a database to store the data.

JSON data type has some methods that can come in handy such as data.key.filter or data.key.find where data is the JSON.

```
../data.json` is relative path

@.data.json` will start from the root directory
```

overall, Composition API (CAPI) is better than Options API (OPAI), CAPI has better organization, type inference (typescript support), and better logic.

For Vue, it is best to name components with two or more words. This way, it will never conflict with any HTML elements as HTML elements only have one word.

When using v-for, you need v-bind the a value to the key like such

```
<div v-for = "item in items" :key = "item.id"></div>
```

To convert OPAI to CAPI:

what is in the export data will be moved out, as CAPI doesn't export data. The non-static data should be reactive, while the static data should be static
 
```
import {reactive, ref} from 'vue'

const var1 = reactive(jsObject)
const var2 = reactive(jsArray)

const var3 = ref(jsBoolean)
const var4 = ref(jsInteger)
```

in order to access these variable values while in the script you need to do

```
console.log(var1, var2)
console.log(var3.value, var4.value)
```

`.value` is needed because ref reference the memory address (?).

`.value` is not needed in the template section.

What is in the methods, simply becomes a function like such:
```
function myMethod (param1) {
    return param1.id
}
```

One thing to note, in CAPI, you no longer need `this` to access the script.

index.html is what gets rendered first for every page. So to add a stylesheet under every page. In index.html, add:

```
<link ref="stylesheet" href="/style.css">
```

It is recommended to have as little global style as possible, as it increases the performance (you only load what you need). You can do this by importing a .css file in the style section, or create your own in the style section, then add the keyword `scoped` to the style section:

```
<style scoped></style>
```

### Chapter 3



## Side Note

Look into Vue Dev Tool on VS Code for easier development